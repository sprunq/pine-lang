use base::located::Located;
use base::source_id::SourceId;
use crate::token::Token;
use crate::ast::stmt::*;
use crate::ast::expr::*;
use crate::ast::op::*;
use crate::ast::ty::*;
use crate::ast::*;
use messages::lexer::LexerError;

grammar<'input>(file_id : SourceId);

extern {
    type Location = usize;
    type Error = LexerError;

    enum Token {
        "(" => Token::LtParen,
        ")" => Token::RtParen,
        "{" => Token::LtBrace,
        "}" => Token::RtBrace,
        "," => Token::Comma,
        "." => Token::Dot,
        "-" => Token::Minus,
        "+" => Token::Plus,
        ";" => Token::Semicolon,
        "/" => Token::Slash,
        "%" => Token::Modulo,
        "*" => Token::Asterisk,
        ":" => Token::Colon,
        "->" => Token::ArrowRight,

        "!" => Token::Bang,
        "!=" => Token::BangEqual,
        "=" => Token::Equal,
        "==" => Token::EqualEqual,
        ">" => Token::Greater,
        ">=" => Token::GreaterEqual,
        "<" => Token::Less,
        "<=" => Token::LessEqual,

        identifier => Token::Identifier(<String>),
        string => Token::String(<String>),
        integer => Token::Integer(<i64>),
        float => Token::Float(<f64>),

        "and" => Token::And,
        "type" => Token::Type,
        "else" => Token::Else,
        "false" => Token::False,
        "fun" => Token::Fun,
        "if" => Token::If,
        "or" => Token::Or,
        "return" => Token::Return,
        "break" => Token::Break,
        "true" => Token::True,
        "let" => Token::Let,
        "loop" => Token::Loop,

        "bool" => Token::TyBool,
        "i8" => Token::TyI8,
        "i32" => Token::TyI32,
        "i64" => Token::TyI64,
        "u8" => Token::TyU8,
        "u32" => Token::TyU32,
        "u64" => Token::TyU64,
        "f32" => Token::TyF32,
        "f64" => Token::TyF64,
        "str" => Token::TyStr,
    }
}


// --------------------------------------------------------------------------------------------------
//                                          Helpers
// --------------------------------------------------------------------------------------------------

// Parses an object of type T, and returns a Pos<T>
Pos<T>: Located<T> = {
    <start: @L> <data: T> <end: @R> => Located::new(file_id, start..end, data),
};

// Parses a comma separated list of T, and returns a Vec<T>
Comma<T>: Vec<T> = { 
    <mut v:(<T> ",")*> <e:T?> => match e { 
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};


// --------------------------------------------------------------------------------------------------
//                                          Declarations
// --------------------------------------------------------------------------------------------------

pub Program: Program = <stmts:Pos<Declaration>*> => Program { <> };

Declaration : Declaration = { 
    DeclTypeObject, 
    DeclFunction
}

DeclTypeObject: Declaration = <decl:DeclTypeObjectInner> => Declaration::TypeObject(<>);
DeclTypeObjectInner: TypeObject = "type" <name:Identifier> "=" "{" <members:Comma<TypedParam>> "}" => TypeObject { <> };

DeclFunction: Declaration = <decl:DeclFunctionInner> => Declaration::Fun(<>);
DeclFunctionInner: StmtFun = "fun" <name:Identifier> "(" <params:Comma<TypedParam>> ")" "->" <ret_ty:Pos<Type>>  <body:StmtBlockInner> => StmtFun { <> };

// --------------------------------------------------------------------------------------------------
//                                          Statements
// --------------------------------------------------------------------------------------------------

Stmt: Stmt = {
    StmtVarDecl,
    StmtIf,
    StmtLoop,
    StmtBlock,
    StmtExpr,
    StmtReturn,
    StmtBreak,
    StmtEmpty,
}

StmtVarDecl: Stmt = "let" <var:Pos<Identifier>> ":" <ty:Pos<Type>> "=" <value:Pos<Expr>> ";" => Stmt::VariableDeclaration(VariableDeclaration { <> });
StmtEmpty: Stmt = <l:@L> ";" <r:@R>  => Stmt::Empty(StmtEmpty{ span : Located::empty(file_id, l..r)});
StmtExpr: Stmt = <value:Pos<Expr>> ";" => Stmt::Expr(StmtExpr { <> });
StmtReturn: Stmt = "return" <value:Pos<Expr>?> ";" => Stmt::Return(StmtReturn { <> });
StmtBreak: Stmt =  <l:@L> "break" ";" <r:@R> => Stmt::Break(StmtBreak { span : Located::empty(file_id, l..r) });

StmtLoop: Stmt = StmtLoopInner => Stmt::Loop(Box::new(<>));
StmtLoopInner: StmtLoop = "loop" <body:Pos<StmtBlock>> => StmtLoop { <> };

StmtBlock: Stmt = StmtBlockInner => Stmt::Block(<>);
StmtBlockInner: StmtBlock = "{" <stmts:Pos<Stmt>*> "}" => StmtBlock { <> };

StmtIf: Stmt = StmtIfInner => Stmt::If(Box::new(<>));
StmtIfInner: StmtIf = "if" "(" <cond:Pos<Expr>> ")" <then:Pos<StmtBlock>> <optional_else : ("else" <Pos<StmtBlock>>)?> => { 
    match optional_else {
        Some(els) => StmtIf { cond, then, else_: Some(els) },
        None => StmtIf { cond, then, else_: None },
    }
};


// --------------------------------------------------------------------------------------------------
//                                          Expressions
// --------------------------------------------------------------------------------------------------

// https://github.com/lalrpop/lalrpop/issues/596
ExprReset = <Expr>;

Expr : Expr = {
    #[precedence(level="0")]
    StructInit,

    #[precedence(level="1")]
    LiteralExpr,
    <var:Identifier> => Expr::Var(ExprVar { <> }),
    "(" <ExprReset> ")" => <>,

    #[precedence(level="2")] #[assoc(side="left")]
    <callee:Pos<Expr>> "(" <args:Comma<Pos<ExprReset>>> ")" => Expr::Call(Box::new(ExprCall { <> })),
    <object:Pos<Expr>> "." <member_name:Pos<Identifier>> => Expr::MemberAccess(Box::new(ExprMemberAccess { <> })),
    
    #[precedence(level="3")] #[assoc(side="left")]
    <op:OpNegate> <rt:Pos<Expr>> => Expr::Prefix(Box::new(ExprPrefix { <> })),
    <op:OpNot>    <rt:Pos<Expr>> => Expr::Prefix(Box::new(ExprPrefix { <> })),

    #[precedence(level="4")] #[assoc(side="left")]
    <lt:Pos<Expr>> <op:OpMultiply>      <rt:Pos<Expr>> => Expr::Infix(Box::new(ExprInfix { <> })),
    <lt:Pos<Expr>> <op:OpDivide>        <rt:Pos<Expr>> => Expr::Infix(Box::new(ExprInfix { <> })),
    <lt:Pos<Expr>> <op:OpModulo>        <rt:Pos<Expr>> => Expr::Infix(Box::new(ExprInfix { <> })),

    #[precedence(level="5")] #[assoc(side="left")]
    <lt:Pos<Expr>> <op:OpAdd>           <rt:Pos<Expr>> => Expr::Infix(Box::new(ExprInfix { <> })),
    <lt:Pos<Expr>> <op:OpSubtract>      <rt:Pos<Expr>> => Expr::Infix(Box::new(ExprInfix { <> })),

    #[precedence(level="6")] #[assoc(side="left")]
    <lt:Pos<Expr>> <op:OpLess>          <rt:Pos<Expr>> => Expr::Infix(Box::new(ExprInfix { <> })),
    <lt:Pos<Expr>> <op:OpLessEqual>     <rt:Pos<Expr>> => Expr::Infix(Box::new(ExprInfix { <> })),
    <lt:Pos<Expr>> <op:OpGreater>       <rt:Pos<Expr>> => Expr::Infix(Box::new(ExprInfix { <> })),
    <lt:Pos<Expr>> <op:OpGreaterEqual>  <rt:Pos<Expr>> => Expr::Infix(Box::new(ExprInfix { <> })),

    #[precedence(level="7")] #[assoc(side="left")]
    <lt:Pos<Expr>> <op:OpEqual>         <rt:Pos<Expr>> => Expr::Infix(Box::new(ExprInfix { <> })),
    <lt:Pos<Expr>> <op:OpNotEqual>      <rt:Pos<Expr>> => Expr::Infix(Box::new(ExprInfix { <> })),

    #[precedence(level="8")] #[assoc(side="left")]
    <lt:Pos<Expr>> <op:OpLogicAnd>      <rt:Pos<Expr>> => Expr::Infix(Box::new(ExprInfix { <> })),

    #[precedence(level="9")] #[assoc(side="left")]
    <lt:Pos<Expr>> <op:OpLogicOr>       <rt:Pos<Expr>> => Expr::Infix(Box::new(ExprInfix { <> })),

    #[precedence(level="10")] #[assoc(side="right")]
    <var:Pos<Expr>> "=" <value:Pos<Expr>> => Expr::Assign(Box::new(ExprAssign { <> }))
}


OpLogicOr: OpInfix = "or" => OpInfix::LogicOr;
OpLogicAnd: OpInfix = "and" => OpInfix::LogicAnd;
OpEqual : OpInfix = "==" => OpInfix::Equal;
OpNotEqual : OpInfix = "!=" => OpInfix::NotEqual;
OpGreater : OpInfix = ">" => OpInfix::Greater;
OpGreaterEqual : OpInfix = ">=" => OpInfix::GreaterEqual;
OpLess : OpInfix = "<" => OpInfix::Less;
OpLessEqual : OpInfix = "<=" => OpInfix::LessEqual;
OpAdd : OpInfix = "+" => OpInfix::Add;
OpSubtract : OpInfix = "-" => OpInfix::Subtract;
OpMultiply : OpInfix = "*" => OpInfix::Multiply;
OpDivide : OpInfix = "/" => OpInfix::Divide;
OpModulo : OpInfix = "%" => OpInfix::Modulo;
OpNegate: OpPrefix = "-" => OpPrefix::Negate;
OpNot: OpPrefix = "!" => OpPrefix::Not;

StructInit: Expr = <name:Identifier> "{" <members: Comma<StructMemberInitPair>> "}" => Expr::StructureInit(ExprStructureInit { <> });
StructMemberInitPair: (Identifier, Located<Expr>) = { <name:Identifier> ":" <value:Pos<Expr>> => (<>) }

Identifier : Identifier = <name:identifier> => Identifier { <> };

LiteralExpr : Expr = {
    "false" => Expr::Literal(ExprLiteral::Bool(false)),
    "true" => Expr::Literal(ExprLiteral::Bool(true)),
    string => Expr::Literal(ExprLiteral::String(<>)),
    integer => Expr::Literal(ExprLiteral::Integer(<>)),
    float => Expr::Literal(ExprLiteral::Float(<>)),
}


// --------------------------------------------------------------------------------------------------
//                                             Types
// --------------------------------------------------------------------------------------------------

TypedParam : TypedParam  = {
    <name:Pos<Identifier>> ":" <ty:Pos<Type>> => TypedParam { <> },
}

Type : Type = {
    "(" ")" => Type::Unit,
    "bool" => Type::Bool,
    "i8" => Type::I8,
    "i32" => Type::I32,
    "i64" => Type::I64,
    "u8" => Type::U8,
    "u32" => Type::U32,
    "u64" => Type::U64,
    "f32" => Type::F32,
    "f64" => Type::F64,
    "str" => Type::String,
    <identifier> => Type::Struct(<>),
}
