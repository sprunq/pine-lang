use base::located::Located;
use base::source_id::SourceId;
use crate::token::Token;
use crate::ast::stmt::*;
use crate::ast::expr::*;
use crate::ast::op::*;
use crate::ast::ty::*;
use crate::ast::*;
use messages::lexer::LexerError;

grammar<'input>(file_id : SourceId);

extern {
    type Location = usize;
    type Error = LexerError;

    enum Token {
        "(" => Token::LtParen,
        ")" => Token::RtParen,
        "{" => Token::LtBrace,
        "}" => Token::RtBrace,
        "," => Token::Comma,
        "." => Token::Dot,
        "-" => Token::Minus,
        "+" => Token::Plus,
        ";" => Token::Semicolon,
        "/" => Token::Slash,
        "%" => Token::Modulo,
        "*" => Token::Asterisk,
        ":" => Token::Colon,
        "->" => Token::ArrowRight,

        "!" => Token::Bang,
        "!=" => Token::BangEqual,
        "=" => Token::Equal,
        "==" => Token::EqualEqual,
        ">" => Token::Greater,
        ">=" => Token::GreaterEqual,
        "<" => Token::Less,
        "<=" => Token::LessEqual,

        identifier => Token::Identifier(<String>),
        string => Token::String(<String>),
        integer => Token::Integer(<i64>),
        float => Token::Float(<f64>),

        "and" => Token::And,
        "type" => Token::Type,
        "else" => Token::Else,
        "false" => Token::False,
        "fun" => Token::Fun,
        "if" => Token::If,
        "or" => Token::Or,
        "return" => Token::Return,
        "break" => Token::Break,
        "true" => Token::True,
        "let" => Token::Let,
        "loop" => Token::Loop,

        "bool" => Token::TyBool,
        "i8" => Token::TyI8,
        "i32" => Token::TyI32,
        "i64" => Token::TyI64,
        "u8" => Token::TyU8,
        "u32" => Token::TyU32,
        "u64" => Token::TyU64,
        "f32" => Token::TyF32,
        "f64" => Token::TyF64,
        "str" => Token::TyStr,
    }
}


pub Program: Program = <stmts:DeclS*> => Program { <> };

// Declarations
TypeS = Located<Type>;
DeclS = Located<Decl>;

Decl = { DeclStruct, DeclFun }

DeclStruct: Declaration = "type" <name:Identifier> "=" "{" <members:Comma<TypedParam>> "}" => Declaration::TypeObject(TypeObject { <> });
DeclFun: Declaration = "fun" <function:Function> => Declaration::Fun(<>);

// Statements
Stmt: Stmt = {
    StmtVarDecl,
    StmtOpen,
    StmtClosed,
    StmtEmpty,
    <e:!> => {
        Stmt::Error
    },
}

StmtVarDecl: Stmt = "let" <var:Identifier> ":" <ty:Located<Type>> "=" <value:ExprS> ";" => Stmt::VariableDeclaration(VariableDeclaration { <> });

StmtEmpty: Stmt =<l:@L> ";" <r:@R>  => Stmt::Empty(StmtEmpty{ span : Located::empty(file_id, l..r)});

// https://en.wikipedia.org/wiki/Dangling_else#Avoiding_the_conflict_in_LR_parsers
StmtOpen: Stmt = {
    "if" "(" <cond:ExprS> ")" <then:Located<Stmt>> => Stmt::If(Box::new(StmtIf { <>, else_: None })),
    
    "if" "(" <cond:ExprS> ")" <then:Located<StmtClosed>> "else" <else_:Located<StmtOpen>> =>
        Stmt::If(Box::new(StmtIf { cond, then, else_: Some(else_) })),
    
    "loop" <body:Located<StmtOpen>> => Stmt::Loop(Box::new(StmtLoop{ <> })),
}

StmtClosed: Stmt = {
    "if" "(" <cond:ExprS> ")" <then:Located<StmtClosed>> "else" <else_:Located<StmtClosed>> => 
        Stmt::If(Box::new(StmtIf { cond, then, else_: Some(else_) })),
    
    "loop" <body:Located<StmtClosed>> => Stmt::Loop(Box::new(StmtLoop { <> })),
    StmtSimple,
}

StmtSimple = {
    StmtBlock,
    StmtExpr,
    StmtReturn,
    StmtBreak,
}

StmtBlock: Stmt = StmtBlockInternal => Stmt::Block(<>);

StmtBlockInternal: StmtBlock = "{" <stmts:StmtS*> "}" => StmtBlock { <> };

StmtExpr: Stmt = <value:ExprS> ";" => Stmt::Expr(StmtExpr { <> });

StmtReturn: Stmt = "return" <value:ExprS?> ";" => Stmt::Return(StmtReturn { <> });

StmtBreak: Stmt =  <l:@L> "break" <r:@R>  ";" => Stmt::Break(StmtBreak { span : Located::empty(file_id, l..r) });


// Expressions
ExprS = Located<Expr>;
StmtS = Located<Stmt>;

Expr = ExprAssign;

ExprAssign = {
    <var:Located<ExprCall>> "=" <value:ExprS> => Expr::Assign(Box::new(ExprAssign { <> })),
    ExprLogicOr,
}

ExprLogicOr = ExprInfix<ExprLogicOr, OpLogicOr, ExprLogicAnd>;
ExprLogicAnd = ExprInfix<ExprLogicAnd, OpLogicAnd, ExprEquality>;
ExprEquality = ExprInfix<ExprEquality, OpEquality, ExprComparison>;
ExprComparison = ExprInfix<ExprComparison, OpComparison, ExprTerm>;
ExprTerm = ExprInfix<ExprTerm, OpTerm, ExprFactor>;
ExprFactor = ExprInfix<ExprFactor, OpFactor, ExprPrefix>;

ExprInfix<Lt, Op, Rt>: Expr = {
    <lt:Located<Lt>> <op:Op> <rt:Located<Rt>> => Expr::Infix(Box::new(ExprInfix { <> })),
    Rt,
}

OpLogicOr: OpInfix = "or" => OpInfix::LogicOr;

OpLogicAnd: OpInfix = "and" => OpInfix::LogicAnd;

OpEquality: OpInfix = {
    "==" => OpInfix::Equal,
    "!=" => OpInfix::NotEqual,
}

OpComparison: OpInfix = {
    ">" => OpInfix::Greater,
    ">=" => OpInfix::GreaterEqual,
    "<" => OpInfix::Less,
    "<=" => OpInfix::LessEqual,
}

OpTerm: OpInfix = {
    "+" => OpInfix::Add,
    "-" => OpInfix::Subtract,
}

OpFactor: OpInfix = {
    "*" => OpInfix::Multiply,
    "/" => OpInfix::Divide,
    "%" => OpInfix::Modulo,
}

ExprPrefix: Expr = {
    <op:OpPrefix> <rt:Located<ExprPrefix>> => Expr::Prefix(Box::new(ExprPrefix { <> })),
    ExprCall,
}

OpPrefix: OpPrefix = {
    "-" => OpPrefix::Negate,
    "!" => OpPrefix::Not,
}

ExprCall: Expr = {
    <callee:Located<ExprCall>> "(" <args:Args> ")" => Expr::Call(Box::new(ExprCall { <> })),
    <object:Located<ExprCall>> "." <member_name:Identifier> => Expr::MemberAccess(Box::new(ExprMemberAccess { <> })),
    ExprPrimary,
}

ExprPrimary: Expr = {
    "false" => Expr::Literal(ExprLiteral::Bool(false)),
    "true" => Expr::Literal(ExprLiteral::Bool(true)),
    string => Expr::Literal(ExprLiteral::String(<>)),
    integer => Expr::Literal(ExprLiteral::Integer(<>)),
    float => Expr::Literal(ExprLiteral::Float(<>)),
    <name:Identifier> "{" <members: StructMemberInit> "}" => Expr::StructureInit(Box::new(ExprStructureInit { <> })),
    ExprVar,
    "(" <Expr> ")",
}

StructMemberInit: Vec<(Identifier, ExprS)> = {
    <first:StructMemberInitPair> <mut members:("," <StructMemberInitPair>)*> => {
        members.insert(0, first);
        members
    },
    () => Vec::new(),
}

StructMemberInitPair: (Identifier, ExprS) = { <name:Identifier> ":" <value:ExprS> => (<>) }

ExprVar: Expr = <var:Identifier> => Expr::Var(ExprVar { <> });

Function: StmtFun = <name:Identifier> "(" <params:Params> ")" "->" <ret_ty:Located<Type>>  <body:StmtBlockInternal> => StmtFun { <> };

Params: Vec<TypedParam> = {
    <first:TypedParam> <mut params:("," <TypedParam>)*> => {
        params.insert(0, first);
        params
    },
    () => Vec::new(),
};

Args: Vec<ExprS> = {
    <first:ExprS> <mut args:("," <ExprS>)*> => {
        args.insert(0, first);
        args
    },
    () => Vec::new(),
}

Identifier : Identifier = <name:identifier> => Identifier { <> };

// Types

TypedParam : TypedParam  = {
    <name:Located<Identifier>> ":" <ty:Located<Type>> => TypedParam { <> },
}

Types: Vec<TypeS> = {
    <first:TypeS> <mut types:("," <TypeS>)*> => {
        types.insert(0, first);
        types
    },
    () => Vec::new(),
}

Type : Type = {
    "(" ")" => Type::Unit,
    "bool" => Type::Bool,
    "i8" => Type::I8,
    "i32" => Type::I32,
    "i64" => Type::I64,
    "u8" => Type::U8,
    "u32" => Type::U32,
    "u64" => Type::U64,
    "f32" => Type::F32,
    "f64" => Type::F64,
    "str" => Type::String,
    <identifier> => Type::Struct(<>),
}

// Utilities

Located<T>: Located<T> = {
    <start: @L> <data: T> <end: @R> => Located::new(file_id, start..end, data),
};

Comma<T>: Vec<T> = { 
    <mut v:(<T> ",")*> <e:T?> => match e { 
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};
